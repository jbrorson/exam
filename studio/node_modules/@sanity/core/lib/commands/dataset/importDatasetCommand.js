'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _got = require('got');

var _got2 = _interopRequireDefault(_got);

var _padStart = require('lodash/padStart');

var _padStart2 = _interopRequireDefault(_padStart);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _prettyMs = require('pretty-ms');

var _prettyMs2 = _interopRequireDefault(_prettyMs);

var _promise = require('linecount/promise');

var _promise2 = _interopRequireDefault(_promise);

var _debug = require('../../debug');

var _debug2 = _interopRequireDefault(_debug);

var _import = require('@sanity/import');

var _import2 = _interopRequireDefault(_import);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = {
  name: 'import',
  group: 'dataset',
  signature: '[FILE] [TARGET_DATASET]',
  description: 'Import dataset from local filesystem',
  action: (() => {
    var _ref = _asyncToGenerator(function* (args, context) {
      const apiClient = context.apiClient,
            output = context.output,
            chalk = context.chalk;


      const operation = getMutationOperation(args.extOptions);

      var _args$argsWithoutOpti = _slicedToArray(args.argsWithoutOptions, 2);

      const file = _args$argsWithoutOpti[0],
            targetDataset = _args$argsWithoutOpti[1];

      if (!file) {
        throw new Error(`Source file name and target dataset must be specified ("sanity dataset import ${chalk.bold('[file]')} [dataset]")`);
      }

      if (!targetDataset) {
        // @todo ask which dataset the user wants to use
        throw new Error(`Target dataset must be specified ("sanity dataset import [file] ${chalk.bold('[dataset]')}")`);
      }

      const isUrl = /^https?:\/\//i.test(file);
      const sourceFile = isUrl ? file : _path2.default.resolve(process.cwd(), file);
      const inputStream = isUrl ? _got2.default.stream(sourceFile) : _fsExtra2.default.createReadStream(sourceFile);
      const client = apiClient();

      const documentCount = isUrl ? 0 : yield (0, _promise2.default)(sourceFile);
      (0, _debug2.default)(documentCount ? 'Could not count documents in source' : `Found ${documentCount} lines in source file`);
      (0, _debug2.default)(`Target dataset has been set to "${targetDataset}"`);

      let spinner = null;

      // Verify existence of dataset before trying to import to it
      (0, _debug2.default)('Verifying if dataset already exists');
      spinner = output.spinner('Checking if destination dataset exists').start();
      const datasets = yield client.datasets.list();
      if (!datasets.find(function (set) {
        return set.name === targetDataset;
      })) {
        // @todo ask if user wants to create it
        spinner.fail();
        throw new Error([`Dataset with name "${targetDataset}" not found.`, `Create it by running "${chalk.cyan(`sanity dataset create ${targetDataset}`)}" first`].join('\n'));
      }
      spinner.succeed();

      const importClient = client.clone().config({ dataset: targetDataset });

      let currentStep;
      let currentProgress;
      let stepStart;
      let spinInterval;
      let percent;

      function onProgress(opts) {
        const lengthComputable = opts.total;
        const sameStep = opts.step == currentStep;
        percent = getPercentage(opts);

        if (lengthComputable && opts.total === opts.current) {
          clearInterval(spinInterval);
          spinInterval = null;
        }

        if (sameStep) {
          return;
        }

        // Moved to a new step
        const prevStep = currentStep;
        const prevStepStart = stepStart || Date.now();
        stepStart = Date.now();
        currentStep = opts.step;

        if (currentProgress && currentProgress.succeed) {
          const timeSpent = (0, _prettyMs2.default)(Date.now() - prevStepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `[100%] ${prevStep} (${timeSpent})`;
          currentProgress.succeed();
        }

        currentProgress = output.spinner(`[0%] ${opts.step} (0.00s)`).start();

        if (spinInterval) {
          clearInterval(spinInterval);
          spinInterval = null;
        }

        spinInterval = setInterval(() => {
          const timeSpent = (0, _prettyMs2.default)(Date.now() - prevStepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `${percent}${opts.step} (${timeSpent})`;
        }, 60);
      }

      function endTask(_ref2) {
        let success = _ref2.success;

        clearInterval(spinInterval);
        spinInterval = null;

        if (success) {
          const timeSpent = (0, _prettyMs2.default)(Date.now() - stepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `[100%] ${currentStep} (${timeSpent})`;
          currentProgress.succeed();
        } else {
          currentProgress.fail();
        }
      }

      // Start the import!
      try {
        const imported = yield (0, _import2.default)(inputStream, {
          client: importClient,
          operation: operation,
          onProgress: onProgress
        });

        endTask({ success: true });

        output.print('Done! Imported %d documents to dataset "%s"', imported, targetDataset);
      } catch (err) {
        endTask({ success: false });
        output.error(err);
      }
    });

    return function action(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  })()
};


function getMutationOperation(flags) {
  const replace = flags.replace,
        missing = flags.missing;

  if (replace && missing) {
    throw new Error('Cannot use both --replace and --missing');
  }

  if (flags.replace) {
    return 'createOrReplace';
  }

  if (flags.missing) {
    return 'createIfNotExists';
  }

  return 'create';
}

function getPercentage(opts) {
  if (!opts.total) {
    return '';
  }

  const percent = Math.floor(opts.current / opts.total * 100);
  return `[${(0, _padStart2.default)(percent, 3, ' ')}%] `;
}