'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePlugin = exports.resolveProjectRoot = undefined;
exports.resolveParts = resolveParts;
exports.default = resolveTree;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _generateHelpUrl = require('@sanity/generate-help-url');

var _generateHelpUrl2 = _interopRequireDefault(_generateHelpUrl);

var _flattenTree = require('./flattenTree');

var _flattenTree2 = _interopRequireDefault(_flattenTree);

var _readManifest = require('./readManifest');

var _readManifest2 = _interopRequireDefault(_readManifest);

var _resolvePlugins = require('./resolvePlugins');

var _resolveProjectRoot = require('./resolveProjectRoot');

var _resolveProjectRoot2 = _interopRequireDefault(_resolveProjectRoot);

var _removeDuplicatePlugins = require('./removeDuplicatePlugins');

var _removeDuplicatePlugins2 = _interopRequireDefault(_removeDuplicatePlugins);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var resolveProjectRoot = exports.resolveProjectRoot = _resolveProjectRoot2.default;
exports.resolvePlugin = _resolvePlugins.resolvePlugin;
function resolveParts() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var options = Object.assign({ basePath: process.cwd() }, opts);

  if (options.sync) {
    return mergeResult(resolveTree(options), options);
  }

  return resolveTree(options).then(function (plugins) {
    return mergeResult(plugins, options);
  });
}

function resolveTreeSync(options) {
  var basePath = options.basePath || process.cwd();
  var manifest = (0, _readManifest2.default)(options);
  var plugins = (0, _resolvePlugins.resolvePlugins)(manifest.plugins || [], options).concat([getProjectRootPlugin(basePath, manifest)]);

  return plugins.reduce(_flattenTree2.default, plugins.slice());
}

function resolveTree() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var options = Object.assign({ basePath: process.cwd() }, opts);

  if (options.resolveProjectRoot) {
    // @todo Sync vs async
    var resolveOpts = Object.assign({}, options, { sync: true });
    options.basePath = (0, _resolveProjectRoot2.default)(resolveOpts);
  }

  var projectManifest = null;

  if (options.sync) {
    return resolveTreeSync(options);
  }

  return (0, _readManifest2.default)(options).then(function (manifest) {
    projectManifest = manifest;
    return (0, _resolvePlugins.resolvePlugins)(manifest.plugins || [], options);
  }).then(function (plugins) {
    return plugins.concat([getProjectRootPlugin(options.basePath, projectManifest)]);
  }).then(function (plugins) {
    return plugins.reduce(_flattenTree2.default, plugins.slice());
  }).then(_removeDuplicatePlugins2.default);
}

function getProjectRootPlugin(basePath, manifest) {
  return {
    name: '(project root)',
    path: basePath,
    manifest: manifest,
    plugins: []
  };
}

function mergeResult(plugins) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var definitions = {};
  var implementations = {};
  var result = { definitions: definitions, implementations: implementations, plugins: plugins

    // Find plugins that define parts, and do a basic validation on the syntax
  };var partPlugins = plugins.map(function (plugin) {
    if (!plugin.manifest.parts) {
      return false;
    }

    if (!Array.isArray(plugin.manifest.parts)) {
      var help = 'See ' + (0, _generateHelpUrl2.default)('plugin-parts-syntax');
      throw new Error('Plugin "' + plugin.name + '" has a "parts" property which is not an array\n' + help);
    }

    return {
      parts: plugin.manifest.parts,
      plugin: plugin
    };
  }).filter(Boolean).reverse();

  partPlugins.forEach(function (_ref) {
    var parts = _ref.parts,
        plugin = _ref.plugin;

    parts.forEach(function (part) {
      if (part.name && part.path) {
        assignNonOverridablePart(plugin, part, implementations, definitions, options);
      } else if (part.name) {
        assignDefinitionForAbstractPart(plugin, part, definitions);
      }

      if (part.implements) {
        assignPartImplementation(plugin, part, implementations, definitions, options);
      }
    });
  });

  return result;
}

function assignNonOverridablePart(plugin, part, implementations, definitions, options) {
  // Actual, non-overridable part
  var prevDefinition = definitions[part.name];
  if (prevDefinition) {
    // Part already exists, non-overridable parts can't be redefined
    var existing = '"' + prevDefinition.plugin + '" (' + prevDefinition.path + ')';
    var current = '"' + plugin.name + '" (' + plugin.path + ')';
    throw new Error('Plugins ' + existing + ' and ' + current + ' both define part "' + part.name + '"' + ' - did you mean to use "implements"?\n' + 'See ' + (0, _generateHelpUrl2.default)('part-declare-vs-implement'));
  }

  definitions[part.name] = getDefinitionDeclaration(plugin, part);
  implementations[part.name] = [getImplementationDeclaration(plugin, part, options)];
}

function assignDefinitionForAbstractPart(plugin, part, definitions) {
  var prevDefinition = definitions[part.name];
  if (prevDefinition && !prevDefinition.loose) {
    // Part already exists, non-overridable parts can't be redefined
    var existing = '"' + prevDefinition.plugin + '" (' + prevDefinition.path + ')';
    var current = '"' + plugin.name + '" (' + plugin.path + ')';
    throw new Error('Plugins ' + existing + ' and ' + current + ' both define part "' + part.name + '"' + ' - did you mean to use "implements"?\n' + 'See ' + (0, _generateHelpUrl2.default)('part-declare-vs-implement'));
  }

  definitions[part.name] = getDefinitionDeclaration(plugin, part);
}

function assignPartImplementation(plugin, part, implementations, definitions, options) {
  var partName = part.implements;
  if (!part.path) {
    var current = '"' + plugin.name + '" (' + plugin.path + ')';
    throw new Error('Plugin ' + current + ' tries to implement a part "' + partName + '",' + ' but did not define a path. Did you mean to use "name"?\n' + 'See ' + (0, _generateHelpUrl2.default)('part-declare-vs-implement'));
  }

  var prevDefinition = definitions[partName];
  if (prevDefinition && !prevDefinition.isAbstract) {
    var existing = '"' + prevDefinition.plugin + '" (' + prevDefinition.path + ')';
    var _current = '"' + plugin.name + '" (' + plugin.path + ')';
    throw new Error('Plugin ' + _current + ' tried to implement part "' + partName + '", which is already declared' + (' as a non-overridable part by ' + existing + ' - ') + 'See ' + (0, _generateHelpUrl2.default)('implement-non-overridable-part'));
  } else if (!prevDefinition) {
    // In some cases, a user might want to declare a new part name and
    // assign it a non-overridable implementation, while simulatenously
    // fulfilling an existing part using `implements`. In this case,
    // `name`, `implements` and `path` are all set, and we want the part
    // referenced in `implements` to be treated as a non-abstract part.
    // This is why we're explicitly setting `isAbstract` to true below
    // `loose` means that this declaration is "implicit" - the part isn't
    // defined as a `name` + `description` combination, so if we come across
    // a plugin that declares the part outright, we want to use that over this
    definitions[partName] = getDefinitionDeclaration(plugin, part, {
      isAbstract: true,
      loose: true
    });
  }

  if (!implementations[partName]) {
    implementations[partName] = [];
  }

  implementations[partName].push(getImplementationDeclaration(plugin, part, options));
}

function getDefinitionDeclaration(plugin, part) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var isAbstract = typeof options.isAbstract === 'undefined' ? typeof part.path === 'undefined' : options.isAbstract;

  return {
    plugin: plugin.name,
    path: plugin.path,
    description: part.description,
    isAbstract: isAbstract,
    loose: options.loose
  };
}

function getImplementationDeclaration(plugin, part, options) {
  var paths = plugin.manifest.paths || {};
  var isLib = options.useCompiledPaths || plugin.path.split(_path2.default.sep).indexOf('node_modules') !== -1;
  var isDotPath = /^\.{1,2}[\\/]/.test(part.path);

  var basePath = isDotPath ? plugin.path : _path2.default.join(plugin.path, (isLib ? paths.compiled : paths.source) || '');

  var filePath = _path2.default.isAbsolute(part.path) ? part.path : _path2.default.resolve(_path2.default.join(basePath, part.path));

  return {
    plugin: plugin.name,
    path: filePath
  };
}